import socket
import sys
import time
import random
import hashlib
import json
from datetime import datetime
import threading
from queue import Queue
import subprocess
import re
from urllib.parse import urlparse

# AI/ML Libraries (Conceptual - Replace with actual implementations)
# from sklearn.model_selection import train_test_split
# from sklearn.linear_model import LogisticRegression
# from tensorflow import keras
# from tensorflow.keras.layers import Input, Dense
# import numpy as np

# --- Configuration ---
TARGET_HOST = "localhost"  # Default target
SCAN_TIMEOUT = 5
VULNERABILITY_THRESHOLD = 0.7  # Threshold for AI-flagged potential vulnerabilities
LOG_FILE = "vulnerability_scan_log.txt"
NMAP_PATH = "/usr/bin/nmap"  # Adjust path if necessary
NIKTO_PATH = "/usr/bin/nikto"  # Adjust path if necessary

# --- Global Data Structures ---
vulnerability_queue = Queue()
scan_results = {}

# --- Utility Functions ---
def log_activity(message):
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    log_entry = f"[{timestamp}] {message}\n"
    with open(LOG_FILE, "a") as f:
        f.write(log_entry)
    print(message)

def run_command(command):
    try:
        result = subprocess.run(command, shell=True, capture_output=True, text=True, check=True)
        return result.stdout, result.stderr
    except subprocess.CalledProcessError as e:
        return None, e.stderr
    except FileNotFoundError as e:
        log_activity(f"Error: {e}")
        return None, str(e)

# --- Vulnerability Scanning Modules ---

def perform_nmap_scan(target):
    log_activity(f"Starting Nmap scan on {target}")
    command = [NMAP_PATH, "-sV", "-O", "-T4", target]
    stdout, stderr = run_command(command)
    if stdout:
        log_activity(f"Nmap scan results for {target}:\n{stdout}")
        # Basic parsing for potential vulnerabilities (can be enhanced with AI)
        vulnerabilities = []
        for line in stdout.splitlines():
            if "open" in line and any(keyword in line.lower() for keyword in ["uncommon", "potentially vulnerable", "outdated"]):
                vulnerabilities.append(line.strip())
        if vulnerabilities:
            vulnerability_queue.put((datetime.now(), target, "Nmap", vulnerabilities))
    else:
        log_activity(f"Nmap scan failed for {target}:\n{stderr}")

def perform_nikto_scan(target):
    parsed_url = urlparse(target)
    if not parsed_url.scheme:
        target = f"http://{target}" # Nikto often expects a scheme
    log_activity(f"Starting Nikto scan on {target}")
    command = [NIKTO_PATH, "-h", target]
    stdout, stderr = run_command(command)
    if stdout:
        log_activity(f"Nikto scan results for {target}:\n{stdout}")
        # Basic parsing for potential vulnerabilities (can be enhanced with AI)
        vulnerabilities = [line.strip() for line in stdout.splitlines() if "+" in line and not line.startswith("+ OSVDB") and not line.startswith("+ Server:")]
        if vulnerabilities:
            vulnerability_queue.put((datetime.now(), target, "Nikto", vulnerabilities))
    else:
        log_activity(f"Nikto scan failed for {target}:\n{stderr}")

# --- AI-Powered Vulnerability Assessment (Conceptual) ---
# This is a placeholder. Real implementation would involve training ML models.
def assess_vulnerability_severity(tool_name, findings):
    severity_scores = []
    for finding in findings:
        # Simple rule-based assessment (replace with ML model)
        if any(keyword in finding.lower() for keyword in ["critical", "remote code execution", "sql injection", "xss"]):
            severity_scores.append(random.uniform(0.8, 0.95))
        elif any(keyword in finding.lower() for keyword in ["high", "disclosure", "bypass"]):
            severity_scores.append(random.uniform(0.6, 0.8))
        elif any(keyword in finding.lower() for keyword in ["medium", "information leak"]):
            severity_scores.append(random.uniform(0.4, 0.6))
        else:
            severity_scores.append(random.uniform(0.2, 0.4))
    if severity_scores:
        return sum(severity_scores) / len(severity_scores)
    return 0.0

# --- Vulnerability Reporting Thread ---
def vulnerability_reporter():
    while True:
        try:
            timestamp, target, tool, findings = vulnerability_queue.get(timeout=5)
            log_activity(f"[POTENTIAL VULNERABILITY DETECTED at {timestamp}] Target: {target}, Tool: {tool}")
            for finding in findings:
                log_activity(f"  - {finding}")

            # Conceptual AI-based severity assessment
            severity_score = assess_vulnerability_severity(tool, findings)
            log_activity(f"  AI-Assessed Severity Score: {severity_score:.2f}")

            if severity_score > VULNERABILITY_THRESHOLD:
                log_activity(f"  [HIGH PRIORITY] Potential high-severity vulnerabilities found on {target}.")

        except Queue.Empty:
            pass
        except Exception as e:
            log_activity(f"Error in vulnerability reporter thread: {e}")
            time.sleep(5)

# --- Main Execution ---
if __name__ == "__main__":
    log_activity("--- AI-Powered Automated Vulnerability Finding ---")

    # Start vulnerability reporter thread
    reporter_thread = threading.Thread(target=vulnerability_reporter)
    reporter_thread.daemon = True
    reporter_thread.start()

    try:
        while True:
            print("\nChoose an action:")
            print("1. Perform Nmap Scan")
            print("2. Perform Nikto Scan")
            print("3. Scan Target with Both (Nmap & Nikto)")
            print("4. Exit")

            choice = input("Enter your choice: ")

            if choice == '1':
                target = input("Enter target host/IP for Nmap scan: ")
                threading.Thread(target=perform_nmap_scan, args=(target,)).start()
            elif choice == '2':
                target = input("Enter target URL/host for Nikto scan: ")
                threading.Thread(target=perform_nikto_scan, args=(target,)).start()
            elif choice == '3':
                target = input("Enter target host/IP/URL for both scans: ")
                threading.Thread(target=perform_nmap_scan, args=(target,)).start()
                threading.Thread(target=perform_nikto_scan, args=(target,)).start()
            elif choice == '4':
                log_activity("Exiting.")
                break
            else:
                print("Invalid choice.")

            time.sleep(0.1)
    except KeyboardInterrupt:
        log_activity("Program interrupted by user.")
    except Exception as e:
        log_activity(f"An unexpected error occurred in the main loop: {e}")
